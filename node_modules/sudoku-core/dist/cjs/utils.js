"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateBoardDifficulty = exports.getRandomCandidateOfCell = exports.addValueToCellIndex = exports.getRemovalCountBasedOnDifficulty = exports.isHardEnough = exports.isEasyEnough = exports.isBoardFinished = exports.generateHouseIndexList = exports.uniqueArray = exports.contains = void 0;
const constants_1 = require("./constants");
//array contains function
const contains = (array, object) => {
    for (let i = 0; i < array.length; i++) {
        if (array[i] === object) {
            return true;
        }
    }
    return false;
};
exports.contains = contains;
const uniqueArray = (array) => {
    const temp = {};
    for (let i = 0; i < array.length; i++)
        temp[array[i]] = true;
    const record = [];
    for (const k in temp)
        record.push(Number(k));
    return record;
};
exports.uniqueArray = uniqueArray;
/* generateHouseIndexList
 * -----------------------------------------------------------------*/
const generateHouseIndexList = (boardSize) => {
    const groupOfHouses = [[], [], []];
    const boxSideSize = Math.sqrt(boardSize);
    for (let i = 0; i < boardSize; i++) {
        const horizontalRow = []; //horizontal row
        const verticalRow = []; //vertical row
        const box = [];
        for (let j = 0; j < boardSize; j++) {
            horizontalRow.push(boardSize * i + j);
            verticalRow.push(boardSize * j + i);
            if (j < boxSideSize) {
                for (let k = 0; k < boxSideSize; k++) {
                    const a = Math.floor(i / boxSideSize) * boardSize * boxSideSize;
                    const b = (i % boxSideSize) * boxSideSize;
                    const boxStartIndex = a + b; //0 3 6 27 30 33 54 57 60
                    box.push(boxStartIndex + boardSize * j + k);
                }
            }
        }
        groupOfHouses[0].push(horizontalRow);
        groupOfHouses[1].push(verticalRow);
        groupOfHouses[2].push(box);
    }
    return groupOfHouses;
};
exports.generateHouseIndexList = generateHouseIndexList;
const isBoardFinished = (board) => {
    return new Array(constants_1.BOARD_SIZE * constants_1.BOARD_SIZE)
        .fill(null)
        .every((_, i) => board[i].value !== null);
};
exports.isBoardFinished = isBoardFinished;
const isEasyEnough = (difficulty, currentDifficulty) => {
    switch (currentDifficulty) {
        case constants_1.DIFFICULTY_EASY:
            return true;
        case constants_1.DIFFICULTY_MEDIUM:
            return difficulty !== constants_1.DIFFICULTY_EASY;
        case constants_1.DIFFICULTY_HARD:
            return difficulty !== constants_1.DIFFICULTY_EASY && difficulty !== constants_1.DIFFICULTY_MEDIUM;
        case constants_1.DIFFICULTY_EXPERT:
            return (difficulty !== constants_1.DIFFICULTY_EASY &&
                difficulty !== constants_1.DIFFICULTY_MEDIUM &&
                difficulty !== constants_1.DIFFICULTY_HARD);
        case constants_1.DIFFICULTY_MASTER:
            return (difficulty !== constants_1.DIFFICULTY_EASY &&
                difficulty !== constants_1.DIFFICULTY_MEDIUM &&
                difficulty !== constants_1.DIFFICULTY_HARD &&
                difficulty !== constants_1.DIFFICULTY_EXPERT);
    }
};
exports.isEasyEnough = isEasyEnough;
const isHardEnough = (difficulty, currentDifficulty) => {
    switch (difficulty) {
        case constants_1.DIFFICULTY_EASY:
            return true;
        case constants_1.DIFFICULTY_MEDIUM:
            return currentDifficulty !== constants_1.DIFFICULTY_EASY;
        case constants_1.DIFFICULTY_HARD:
            return (currentDifficulty !== constants_1.DIFFICULTY_EASY &&
                currentDifficulty !== constants_1.DIFFICULTY_MEDIUM);
        case constants_1.DIFFICULTY_EXPERT:
            return (currentDifficulty !== constants_1.DIFFICULTY_EASY &&
                currentDifficulty !== constants_1.DIFFICULTY_MEDIUM &&
                currentDifficulty !== constants_1.DIFFICULTY_HARD);
        case constants_1.DIFFICULTY_MASTER:
            return (currentDifficulty !== constants_1.DIFFICULTY_EASY &&
                currentDifficulty !== constants_1.DIFFICULTY_MEDIUM &&
                currentDifficulty !== constants_1.DIFFICULTY_HARD &&
                currentDifficulty !== constants_1.DIFFICULTY_EXPERT);
    }
};
exports.isHardEnough = isHardEnough;
const getRemovalCountBasedOnDifficulty = (difficulty) => {
    switch (difficulty) {
        case constants_1.DIFFICULTY_EASY:
            return constants_1.BOARD_SIZE * constants_1.BOARD_SIZE - 38;
        case constants_1.DIFFICULTY_MEDIUM:
            return constants_1.BOARD_SIZE * constants_1.BOARD_SIZE - 30;
        case constants_1.DIFFICULTY_HARD:
            return constants_1.BOARD_SIZE * constants_1.BOARD_SIZE - 20;
        default:
            return constants_1.BOARD_SIZE * constants_1.BOARD_SIZE - 17;
    }
};
exports.getRemovalCountBasedOnDifficulty = getRemovalCountBasedOnDifficulty;
/* addValueToCellIndex - does not update UI
          -----------------------------------------------------------------*/
const addValueToCellIndex = (board, cellIndex, value) => {
    board[cellIndex].value = value;
    if (value !== null) {
        board[cellIndex].candidates = constants_1.NULL_CANDIDATE_LIST.slice();
    }
};
exports.addValueToCellIndex = addValueToCellIndex;
const getRandomCandidateOfCell = (candidates) => {
    const randomIndex = Math.floor(Math.random() * candidates.length);
    return candidates[randomIndex];
};
exports.getRandomCandidateOfCell = getRandomCandidateOfCell;
/* calculateBoardDifficulty
 * --------------
 *  TYPE: solely based on strategies required to solve board (i.e. single count per strategy)
 *  SCORE: distinguish between boards of same difficulty.. based on point system. Needs work.
 * -----------------------------------------------------------------*/
const calculateBoardDifficulty = (usedStrategies, strategies) => {
    const validUsedStrategies = usedStrategies.filter(Boolean);
    const totalScore = validUsedStrategies.reduce((accumulatedScore, frequency, i) => {
        const strategy = strategies[i];
        return accumulatedScore + frequency * strategy.score;
    }, 0);
    let difficulty = validUsedStrategies.length < 3
        ? constants_1.DIFFICULTY_EASY
        : validUsedStrategies.length < 4
            ? constants_1.DIFFICULTY_MEDIUM
            : constants_1.DIFFICULTY_HARD;
    if (totalScore > 750)
        difficulty = constants_1.DIFFICULTY_EXPERT;
    if (totalScore > 2200)
        difficulty = constants_1.DIFFICULTY_MASTER;
    return {
        difficulty,
        score: totalScore,
    };
};
exports.calculateBoardDifficulty = calculateBoardDifficulty;
